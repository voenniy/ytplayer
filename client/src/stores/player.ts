import { create } from "zustand";
import { persist } from "zustand/middleware";
import type { Track } from "@/lib/api";

interface PlayerState {
  currentTrack: Track | null;
  queue: Track[];
  currentIndex: number;
  isPlaying: boolean;
  repeatMode: "off" | "one";
  searchResults: Track[];
  nextPageToken: string | null;

  play: (track: Track) => void;
  playFromQueue: (index: number) => void;
  pause: () => void;
  resume: () => void;
  addToQueue: (track: Track) => void;
  removeFromQueue: (index: number) => void;
  playNext: () => void;
  playPrev: () => void;
  toggleRepeat: () => void;
  setSearchResults: (tracks: Track[], nextPageToken?: string) => void;
  appendSearchResults: (tracks: Track[], nextPageToken?: string) => void;
  clearQueue: () => void;
  shuffle: () => void;
}

export const usePlayerStore = create<PlayerState>()(
  persist(
    (set, get) => ({
      currentTrack: null,
      queue: [],
      currentIndex: -1,
      isPlaying: false,
      repeatMode: "off" as const,
      searchResults: [],
      nextPageToken: null,

      play: (track) => {
        const idx = get().queue.findIndex((t) => t.id === track.id);
        set({ currentTrack: track, isPlaying: true, currentIndex: idx });
      },

      playFromQueue: (index) => {
        const { queue } = get();
        if (index < 0 || index >= queue.length) return;
        set({
          currentTrack: queue[index],
          currentIndex: index,
          isPlaying: true,
        });
      },

      pause: () => set({ isPlaying: false }),
      resume: () => set({ isPlaying: true }),

      addToQueue: (track) =>
        set((state) => ({ queue: [...state.queue, track] })),

      removeFromQueue: (index) =>
        set((state) => {
          const newQueue = state.queue.filter((_, i) => i !== index);
          let newIndex = state.currentIndex;
          if (index < state.currentIndex) {
            newIndex--;
          } else if (index === state.currentIndex) {
            // Removing current track: stay at same index (next track slides in)
            // If it was the last item, step back
            if (newIndex >= newQueue.length) {
              newIndex = newQueue.length - 1;
            }
          }
          return { queue: newQueue, currentIndex: newIndex };
        }),

      playNext: () => {
        const { queue, currentIndex } = get();
        const nextIdx = currentIndex + 1;
        if (nextIdx >= queue.length) {
          set({ isPlaying: false });
          return;
        }
        set({
          currentTrack: queue[nextIdx],
          currentIndex: nextIdx,
          isPlaying: true,
        });
      },

      toggleRepeat: () =>
        set((state) => ({
          repeatMode: state.repeatMode === "off" ? "one" : "off",
        })),

      playPrev: () => {
        const { queue, currentIndex } = get();
        if (currentIndex <= 0) return;
        const prevIdx = currentIndex - 1;
        set({
          currentTrack: queue[prevIdx],
          currentIndex: prevIdx,
          isPlaying: true,
        });
      },

      setSearchResults: (tracks, nextPageToken) =>
        set({ searchResults: tracks, nextPageToken: nextPageToken ?? null }),

      appendSearchResults: (tracks, nextPageToken) =>
        set((state) => {
          const existingIds = new Set(state.searchResults.map((t) => t.id));
          const newTracks = tracks.filter((t) => !existingIds.has(t.id));
          return {
            searchResults: [...state.searchResults, ...newTracks],
            nextPageToken: nextPageToken ?? null,
          };
        }),

      clearQueue: () =>
        set({ queue: [], currentIndex: -1, currentTrack: null, isPlaying: false }),

      shuffle: () =>
        set((state) => {
          const { currentIndex } = state;
          const before = state.queue.slice(0, currentIndex + 1);
          const after = [...state.queue.slice(currentIndex + 1)];
          for (let i = after.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [after[i], after[j]] = [after[j], after[i]];
          }
          return { queue: [...before, ...after] };
        }),
    }),
    {
      name: "musicplay-player",
      partialize: (state) => ({
        currentTrack: state.currentTrack,
        queue: state.queue,
        currentIndex: state.currentIndex,
        repeatMode: state.repeatMode,
        searchResults: state.searchResults,
        nextPageToken: state.nextPageToken,
      }),
    },
  ),
);
